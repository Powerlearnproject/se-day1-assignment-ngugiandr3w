[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18367105&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the design, development, testing, and maintenance of software. It's importance involve driving innovation, building reliable systems, boosting economic growth, facilitating everyday life, solving problems and promoting digital transformation.


Identify and describe at least three key milestones in the evolution of software engineering.
1. Software Crisis and the Emergence Of Structured Programming (1960s to 1980s)- software projects were over-budget, missed deadlines and failed to meet requirements. Software projects were very complex and lacked formal development practices. This led to the emergence of structured programming with a view on modularity, top-down design, and disciplined coding practices.
2. The Rise of Object-Oriented Programming (OOP) (1980s to 1990s) - OOP emphasizes the use of "objects" that encapsulate data and behavior, promoting code reusability and modularity. Languages like C++ and Java gained popularity and OOP became a dominant approach in software development as programmers could now create complex software and maintain it far better.
3. The Advent of Agile Methodologies and DevOps (1990s to Present) - Agile methodologies such as Scrum and Kanban emerged as a response to the limitations of traditional, rigid methodologies. Agile emphasizes iterative development, collaboration, and adaptability. DevOps practices further enhance collaboration by integrating software development and IT operations, enabling faster and more reliable software releases.

List and briefly explain the phases of the Software Development Life Cycle.
1. Planning - defines the project's scope, goals, and feasibility. Includes resource allocation, scheduling, and risk assessment.
2. Requirements Analysis - gathering requirements from stakeholders to understand user needs, business processes, and system functionalities.
3. Design - focuses on designing the software architecture, user interface, and database. It is the blueprint for development.
4. Implementation/Coding - developers write the source code based on the design specifications.
5. Testing - rogorously testing the software to identify and fix defects. This is done by various testing methods such as unit testing, integration testing, system testing, and user acceptance testing.
6. Deployment - after thorough testing, the software is deployed to the production environment where it is installed and configured on the target servers and made available to users.
7. Maintenance - monitoring software performance, fixing bugs,and providing updates and enhancements to ensure the software remains reliable and it meets evolving user needs.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall Methodology is a linear, sequential approach where each phase of SDLC is completed before moving to the next. It has an emphasis on thorough planning and documentation upfront. Changes are difficult and costly to implement once a phase is completed. An example of a scenario for use of Waterfall Methodology would be developing software for a critical medical device where precise, unchaning requirements are essential.
Agile Methodology is an iterative and incremental approach that is flexible and adaptable, breaking down projects to smaller, manageable iterations(sprints). It focuses on continuous feedback, collaboration, and customer involvement since it emraces change and allows for adjustments throughout the development process. An example of a scenario for use of Agile Methodology is developing a mobile app where user feedback and market trends can lead to frequent updates and change.
Waterfall has low flexibility while Agile has high flexibility. Waterfall is difficult and costly to implement changes on while Agile embraces and adapts to change. Waterfall needs comprehensive planning upfront while Agile needs iterative planning throughout the project.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
1. Software Developer - writing and maintaining code, designing and implementing software solutions, debugging and troubleshooting, code reviews and keeping up-to-date with tech.
2. Quality Assurance Engineer - developing and executing test plans, identifying and reporting defects, performing various types of testing, ensuring software meets quality standards, resolve bugs with help from developers and automation testing.
3. Project Manager - planning and scheduling projects, managing project resources and budgets, monitoring project progress, communicating with stakeholders, managing project risks, facilitating team communication and collaboration.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
1. IDEs - increased productivity, code assistance, debugging tools, integration with other tools and organizing and managing large codebases. e.g, Visual Studio (Microsoft), IntelliJ IDEA (JetBrains) for Java development, Eclipse, VS Code (Microsoft) and Xcode (Apple).
2. VCS - enables collaborations by multiple developers simultaneously, code history over time, allows developers to create branches for different features or bug fixes and then merge them to back into the main codebase, provides a reliable backup of the codebase, provides detailed history of changes, useful for auditing and tracking bugs. eg, Git, GitHub/GitLab/Bitbucket, SVN (Subversion) and Mercurial.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1. Evolving requirements - To overcome this challenge, engineers must be adaptable and able to icorporate changes while minimizing project disruption.
2. Technical debt - engineers should avoid using shortcuts or quick fixes as over time this will slow down development,increase maintenance costs and make it difficult to implement new features.
3. Keeping up with tech - engineers must commit to lifelong learning so as to stay relevant and evolve with the software industry which is constantky changing.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. Unit testing - testing individual, isolated components or 'units' of code which are functions, methods, or classes. Used for; early bug detection, code confidence, code reuseability, simplifying debugging and driving development.
2. Integration testing - testing interactions between different units or components of the software and verifying that the units work together correctly as a group. Used for; interface verification, detecting interaction bugs and ensuring the system works correctly with external systems or APIs.
3. System testing - evaluates the complete, integrated system against its specified requirements. Tests the system as a whole, from end to end, to ensure it meets all requirements. Used to; verify complete system functionality, test performance, security, usability and other non-functional aspects of the system, ensure the system works correctly in a realistic environment and ensure the system meets outlined requirements.
4. Acceptance testing - determines whether the system meets customer's expectations and requirements. Used to; ensure customer satisfaction, validate the system works in the real world, confirm the system meets the business objective and get final approval for system release.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
